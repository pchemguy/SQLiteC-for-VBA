VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "FixUtils"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_Description = "Provides convenience utilities"
'@Folder "SQLite.Fixtures"
'@ModuleDescription "Provides convenience utilities"
'@PredeclaredId
'@IgnoreModule IndexedDefaultMemberAccess, IntegerDataType
Option Explicit


'''' Examples:
''''   >>>?Fixutils.AsciiByteArrayToString(FixUtils.ByteArray(65, 66, 67))
''''   "ABC"
''''
''''   >>>?Fixutils.AsciiByteArrayToString(FixUtils.ByteArray("ABC"))
''''   "ABC"
''''
'@Description "Generates VBA string from ASCII byte array"
Public Function AsciiByteArrayToString(ByRef AsciiBytes() As Byte) As String
Attribute AsciiByteArrayToString.VB_Description = "Generates VBA string from ASCII byte array"
    AsciiByteArrayToString = StrConv(AsciiBytes, vbUnicode)
End Function


'''' Generates byte array from arguments.
''''
'''' Takes elements to be placed in a newly generated Byte Array. Valid
'''' arguments:
''''   - ParamArray list of elements
''''   - 1D 0-based array of elements as a sole argument
''''   - an ASCII string as a sole arguments
'''' Valid elements:
''''   - numeric from [0, 255] (real numbers are rounded during typecasting)
''''   - single ASCII-character string
'''' If the format of the argument list does not match one of the requried
'''' options or elements cannot be typecast to byte, TypeMismatch error is
'''' raised.
''''
'@Description "Generates byte array from either multiple single byte arguments or a single string of ASCII letters"
Public Function ByteArray(ParamArray Values() As Variant) As Byte()
Attribute ByteArray.VB_Description = "Generates byte array from either multiple single byte arguments or a single string of ASCII letters"
    Dim ValuesLocal As Variant
    ValuesLocal = UnfoldParamArray(Values)
    Dim Buffer() As Byte
    Dim Size As Long
    Dim ByteIndex As Long
    If UBound(ValuesLocal) > 0 Then
        Size = UBound(ValuesLocal)
        ReDim Buffer(0 To Size)
        Dim Element As Variant
        For ByteIndex = 0 To Size
            Element = ValuesLocal(ByteIndex)
            Select Case VarType(Element)
                Case vbByte
                    Buffer(ByteIndex) = Element
                Case vbInteger, vbLong, vbLongLong, vbCurrency, vbSingle, vbDouble
                    If Round(Element, 0) < 0 Or Round(Element, 0) > 255 Then GoTo INVALID_INPUT:
                    Buffer(ByteIndex) = CByte(Element)
                Case vbString
                    If Len(Element) <> 1 Then GoTo INVALID_INPUT:
                    Buffer(ByteIndex) = Asc(Element)
                Case Else
                    GoTo INVALID_INPUT:
            End Select
        Next ByteIndex
    ElseIf VarType(ValuesLocal(0)) = vbString Then
        Size = Len(ValuesLocal(0)) - 1
        ReDim Buffer(0 To Size)
        For ByteIndex = 0 To Size
            Buffer(ByteIndex) = Asc(Mid$(ValuesLocal(0), ByteIndex + 1, 1))
        Next ByteIndex
    Else
        GoTo INVALID_INPUT:
    End If
    
    ByteArray = Buffer
    Exit Function
    
INVALID_INPUT:
    Err.Raise ErrNo.TypeMismatchErr, "SQLiteCTestFixObj", _
              "Invalid input for byte array. Element #" & _
              CStr(ByteIndex + 1) & " <<" & CStr(Element) & ">>"
End Function


'''' Examples:
''''   >>>?FixUtils.ByteToHex(&H41)
''''   "41"
''''
'@Description "Given a byte, generates its hex string representation."
Public Function ByteToHex(ByVal ByteCode As Byte) As String
Attribute ByteToHex.VB_Description = "Given a byte, generates its hex string representation."
    Dim HexDigitMap As Variant
    HexDigitMap = Array("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F")
    ByteToHex = HexDigitMap(ByteCode \ 16) & HexDigitMap(ByteCode Mod 16)
End Function


'''' Examples:
''''   FixUtils.BytesFromHexString("0xFF") -> (255)
''''
'@Description "converts hex-encoded string to byte array."
Public Function BytesFromHexString(ByVal HexString0x As String) As Byte()
Attribute BytesFromHexString.VB_Description = "converts hex-encoded string to byte array."
    '''' Remove readability aids: [ .|:]
    Dim Buffer As String
    Buffer = Replace(HexString0x, " ", vbNullString)
    Buffer = Replace(Buffer, ".", vbNullString)
    Buffer = Replace(Buffer, "|", vbNullString)
    Buffer = Replace(Buffer, ":", vbNullString)
    
    '''' Verify that the argument is not empty, has even length, and starts with '0x'.
    If Len(Buffer) = 0 Then
        Err.Raise 13, "FixUtils", "Empty string received."
    ElseIf Len(Buffer) Mod 2 <> 0 Then
        Err.Raise 13, "FixUtils", "HexString must have even length."
    ElseIf UCase$(Left$(Buffer, 2)) <> "0X" Then
        Err.Raise 13, "FixUtils", "HexString must have '0x' prefix."
    End If
    
    Dim HexByteCodes As String
    HexByteCodes = UCase$(Right$(Buffer, Len(Buffer) - 2))
    Dim ByteCount As Long
    ByteCount = Len(HexByteCodes) \ 2
    Dim Bytes() As Byte
    ReDim Bytes(0 To ByteCount - 1)
    Dim ByteIndex As Long
    Dim HiBits As Byte
    Dim LoBits As Byte
    For ByteIndex = 0 To ByteCount - 1
        HiBits = Asc(Mid$(HexByteCodes, ByteIndex * 2 + 1, 1))
        LoBits = Asc(Mid$(HexByteCodes, ByteIndex * 2 + 2, 1))
        If HiBits < Asc("0") Or HiBits > Asc("F") Or _
           HiBits > Asc("9") And HiBits < Asc("A") Or _
           LoBits < Asc("0") Or LoBits > Asc("F") Or _
           LoBits > Asc("9") And LoBits < Asc("A") _
           Then
          Err.Raise 13, "FixUtils", "Invalid hex digits found."
        End If
        HiBits = HiBits - &H30
        LoBits = LoBits - &H30
        HiBits = IIf(HiBits > 9, HiBits - 7, HiBits)
        LoBits = IIf(LoBits > 9, LoBits - 7, LoBits)
        Bytes(ByteIndex) = HiBits * 16 + LoBits
    Next ByteIndex
    BytesFromHexString = Bytes
End Function


'@Description "Generates Dictionary from separate arrays of keys and values"
Public Function KeysValuesToDict(ByVal Keys As Variant, ByVal Values As Variant) As Scripting.Dictionary
Attribute KeysValuesToDict.VB_Description = "Generates Dictionary from separate arrays of keys and values"
    Guard.NotArray Keys
    Guard.NotArray Values
    Guard.IncompatibleArrays Keys, Values
    
    Dim Items As Scripting.Dictionary
    Set Items = New Scripting.Dictionary
    Items.CompareMode = TextCompare
    Dim ObjValue As Object
    Dim ItemIndex As Long
    For ItemIndex = LBound(Keys) To UBound(Keys)
        If Not IsObject(Values(ItemIndex)) Then
            Items(Keys(ItemIndex)) = Values(ItemIndex)
        Else
            Set ObjValue = Values(ItemIndex)
            Set Items(Keys(ItemIndex)) = ObjValue
        End If
    Next ItemIndex
    Set KeysValuesToDict = Items
End Function


'@Description "Calculates XOR-hash of a whole number array."
Public Function XorElements(ByVal Elements As Variant) As Variant
Attribute XorElements.VB_Description = "Calculates XOR-hash of a whole number array."
    Guard.NotArray Elements
    Select Case VarType(Elements(LBound(Elements)))
        Case vbByte, vbInteger, vbLong, vbLongLong, vbBoolean, vbCurrency
            #If Win64 Then
                Dim Result As LongLong
            #Else
                Dim Result As Long
            #End If
            Result = 0
            Dim ElementIndex As Long
            For ElementIndex = LBound(Elements) To UBound(Elements)
                Result = Result Xor Elements(ElementIndex)
            Next ElementIndex
        Case Else
            Err.Raise ErrNo.TypeMismatchErr, "FixUtils", _
                      "Expected an array of whole numbers."
    End Select
    XorElements = Result
End Function


'''' Arguments:
''''   DynamicTypedArray (1D variant array):
''''     ByRef argument declared as "Dim ArrayName() As ArrayType"
''''
''''   BaseIndex (Long):
''''     Low boundary of the ReDim'ed array.
''''
''''   ArrayElements (variant):
''''     Either a variable list or a 0-based 1D array (such as returned by
''''     Array()) of elements. The type of elements should be compatible
''''     with "ArrayType". Automatic typecasting is performed by VBA, if
''''     possible. Otherwise, it should raise the TypeMismatch error.
''''
'@Ignore ParameterCanBeByVal: False positive
'@Description "Populates a dynamic typed array."
Public Function ArrayXB(ByRef DynamicTypedArray As Variant, _
                        ByVal BaseIndex As Long, _
                   ParamArray ArrayElements() As Variant) As Variant
Attribute ArrayXB.VB_Description = "Populates a dynamic typed array."
    Guard.NotArray DynamicTypedArray
    Dim Elements As Variant
    Elements = UnfoldParamArray(ArrayElements)
    ReDim DynamicTypedArray(BaseIndex To UBound(Elements) + BaseIndex)
    
    Dim ElementIndex As Long
    For ElementIndex = 0 To UBound(Elements)
        DynamicTypedArray(ElementIndex + BaseIndex) = Elements(ElementIndex)
    Next ElementIndex
    ArrayXB = DynamicTypedArray
End Function


'@Description "Returns sample 2D array"
Public Function People2D() As Variant
Attribute People2D.VB_Description = "Returns sample 2D array"
    People2D = RowsToTable(Array( _
        Array("id", "first_name", "last_name", "age", "gender", "email", "country", "domain"), _
        Array(1, "Teresa", "Glover", 52, "male", "Teresa.Glover@bol.com.br", "Macedonia", "hiphopmyway.com"), _
        Array(2, "Bramwell", "Simpson", 69, "female", "Bramwell.Simpson@hotmail.com", "Guinea-Bissau", "vcmedia.vn"), _
        Array(3, "Kay", "Seals", 62, "male", "Kay.Seals@laposte.net", "Kazakhstan", "c4tracking01.com"), _
        Array(4, "Edna", "Jennings", 26, "male", "Edna.Jennings@neuf.fr", "Belarus", "taptica.com"), _
        Array(5, "Kimble", "Graeme", 57, "male", "Kimble.Graeme@yahoo.co.id", "Suriname", "nvhrlq.cc"), _
        Array(6, "Buck", "Bowers", 68, "female", "Buck.Bowers@live.co.uk", "Lesotho", "cloudmark.com"), _
        Array(7, "Lana", "Wilson", 41, "male", "Lana.Wilson@yahoo.com.ar", "Maldives", "mobogenie.com"), _
        Array(8, "Ethan", "Jacobson", 79, "male", "Ethan.Jacobson@neuf.fr", "Paraguay", "echo.msk.ru"), _
        Array(9, "Cindy", "Brailsford", 75, "female", "Cindy.Brailsford@windstream.net", "Latvia", "feiwei.tv"), _
        Array(10, "Sylvester", "Creelman", 45, "male", "Sylvester.Creelman@yahoo.com", "Cameroon", "kmplayer.com") _
    ))
End Function


'@Ignore ProcedureNotUsed
'@Description "Returns sample 2D array with some field names containing spaces"
Public Function People2DSpacesInFieldNames() As Variant
Attribute People2DSpacesInFieldNames.VB_Description = "Returns sample 2D array with some field names containing spaces"
    Dim TableData As Variant
    TableData = People2D
    TableData(0, 1) = "first name"
    TableData(0, 2) = "last name"
    People2DSpacesInFieldNames = TableData
End Function


'@Description "Converts 1D array of 1D arrays to 2D array"
Public Function RowsToTable(ByRef TableRows As Variant) As Variant
Attribute RowsToTable.VB_Description = "Converts 1D array of 1D arrays to 2D array"
    Guard.NotArray TableRows
    Guard.NotArray TableRows(LBound(TableRows))
    
    Dim RowLow As Long
    RowLow = LBound(TableRows)
    Dim RowHigh As Long
    RowHigh = UBound(TableRows)
    
    Dim ColumnLow As Long
    ColumnLow = LBound(TableRows(RowLow))
    Dim ColumnHigh As Long
    ColumnHigh = UBound(TableRows(RowLow))
    
    Dim Values() As Variant
    ReDim Values(RowLow To RowHigh, ColumnLow To ColumnHigh)
    Dim ColumnIndex As Long
    Dim RowIndex As Long
    For RowIndex = RowLow To RowHigh
        For ColumnIndex = ColumnLow To ColumnHigh
            Values(RowIndex, ColumnIndex) = TableRows(RowIndex)(ColumnIndex)
        Next ColumnIndex
    Next RowIndex
    RowsToTable = Values
End Function
