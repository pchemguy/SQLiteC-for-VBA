VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "FixUtils"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_Description = "Provides convenience utilities"
'@Folder "SQLite.Fixtures"
'@ModuleDescription "Provides convenience utilities"
'@PredeclaredId
'@IgnoreModule IndexedDefaultMemberAccess
Option Explicit


'''' Examples:
''''   >>>?Fixutils.AsciiByteArrayToString(FixUtils.ByteArray(65, 66, 67))
''''   "ABC"
''''
''''   >>>?Fixutils.AsciiByteArrayToString(FixUtils.ByteArray("ABC"))
''''   "ABC"
''''
'@Description "Generates VBA string from ASCII byte array"
Public Function AsciiByteArrayToString(ByRef AsciiBytes() As Byte) As String
Attribute AsciiByteArrayToString.VB_Description = "Generates VBA string from ASCII byte array"
    AsciiByteArrayToString = StrConv(AsciiBytes, vbUnicode)
End Function


'''' Generates byte array from arguments.
''''
'''' Takes elements to be placed in a newly generated Byte Array. Valid
'''' arguments:
''''   - ParamArray list of elements
''''   - 1D 0-based array of elements as a sole argument
''''   - an ASCII string as a sole arguments
'''' Valid elements:
''''   - numeric from [0, 255] (real numbers are rounded during typecasting)
''''   - single ASCII-character string
'''' If the format of the argument list does not match one of the requried
'''' options or elements cannot be typecast to byte, TypeMismatch error is
'''' raised.
''''
'@Description "Generates byte array from either multiple single byte arguments or a single string of ASCII letters"
Public Function ByteArray(ParamArray Values() As Variant) As Byte()
Attribute ByteArray.VB_Description = "Generates byte array from either multiple single byte arguments or a single string of ASCII letters"
    Dim ValuesLocal As Variant
    ValuesLocal = UnfoldParamArray(Values)
    Dim Buffer() As Byte
    Dim Size As Long
    Dim ByteIndex As Long
    If UBound(ValuesLocal) > 0 Then
        Size = UBound(ValuesLocal)
        ReDim Buffer(0 To Size)
        Dim Element As Variant
        For ByteIndex = 0 To Size
            Element = ValuesLocal(ByteIndex)
            Select Case VarType(Element)
                Case vbByte
                    Buffer(ByteIndex) = Element
                Case vbInteger, vbLong, vbLongLong, vbCurrency, vbSingle, vbDouble
                    If Round(Element, 0) < 0 Or Round(Element, 0) > 255 Then GoTo INVALID_INPUT:
                    Buffer(ByteIndex) = CByte(Element)
                Case vbString
                    If Len(Element) <> 1 Then GoTo INVALID_INPUT:
                    Buffer(ByteIndex) = Asc(Element)
                Case Else
                    GoTo INVALID_INPUT:
            End Select
        Next ByteIndex
    ElseIf VarType(ValuesLocal(0)) = vbString Then
        Size = Len(ValuesLocal(0)) - 1
        ReDim Buffer(0 To Size)
        For ByteIndex = 0 To Size
            Buffer(ByteIndex) = Asc(Mid$(ValuesLocal(0), ByteIndex + 1, 1))
        Next ByteIndex
    Else
        GoTo INVALID_INPUT:
    End If
    
    ByteArray = Buffer
    Exit Function
    
INVALID_INPUT:
    Err.Raise ErrNo.TypeMismatchErr, "SQLiteCTestFixObj", _
              "Invalid input for byte array. Element #" & _
              CStr(ByteIndex + 1) & " <<" & CStr(Element) & ">>"
End Function


'''' Examples:
''''   >>>?FixUtils.ByteToHex(&H41)
''''   "41"
''''
'@Description "Given a byte, generates its hex string representation."
Public Function ByteToHex(ByVal ByteCode As Byte) As String
Attribute ByteToHex.VB_Description = "Given a byte, generates its hex string representation."
    Dim HexDigitMap As Variant
    HexDigitMap = Array("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F")
    ByteToHex = HexDigitMap(ByteCode \ 16) & HexDigitMap(ByteCode Mod 16)
End Function


'@Description "Generates Dictionary from separate arrays of keys and values"
Public Function KeysValuesToDict(ByVal Keys As Variant, ByVal Values As Variant) As Scripting.Dictionary
Attribute KeysValuesToDict.VB_Description = "Generates Dictionary from separate arrays of keys and values"
    Guard.NotArray Keys
    Guard.NotArray Values
    Guard.IncompatibleArrays Keys, Values
    
    Dim Items As Scripting.Dictionary
    Set Items = New Scripting.Dictionary
    Items.CompareMode = TextCompare
    Dim ObjValue As Object
    Dim ItemIndex As Long
    For ItemIndex = LBound(Keys) To UBound(Keys)
        If Not IsObject(Values(ItemIndex)) Then
            Items(Keys(ItemIndex)) = Values(ItemIndex)
        Else
            Set ObjValue = Values(ItemIndex)
            Set Items(Keys(ItemIndex)) = ObjValue
        End If
    Next ItemIndex
    Set KeysValuesToDict = Items
End Function


'@Description "Calculates XOR-hash of a whole number array."
Public Function XorElements(ByVal Elements As Variant) As Variant
Attribute XorElements.VB_Description = "Calculates XOR-hash of a whole number array."
    Guard.NotArray Elements
    Select Case VarType(Elements(LBound(Elements)))
        Case vbByte, vbInteger, vbLong, vbLongLong, vbBoolean, vbCurrency
            #If Win64 Then
                Dim Result As LongLong
            #Else
                Dim Result As Long
            #End If
            Result = 0
            Dim ElementIndex As Long
            For ElementIndex = LBound(Elements) To UBound(Elements)
                Result = Result Xor Elements(ElementIndex)
            Next ElementIndex
        Case Else
            Err.Raise ErrNo.TypeMismatchErr, "FixUtils", _
                      "Expected an array of whole numbers."
    End Select
    XorElements = Result
End Function


'''' Arguments:
''''   DynamicTypedArray (1D variant array):
''''     ByRef argument declared as "Dim ArrayName() As ArrayType"
''''
''''   BaseIndex (Long):
''''     Low boundary of the ReDim'ed array.
''''
''''   ArrayElements (variant):
''''     Either a variable list or a 0-based 1D array (such as returned by
''''     Array()) of elements. The type of elements should be compatible
''''     with "ArrayType". Automatic typecasting is performed by VBA, if
''''     possible. Otherwise, it should raise the TypeMismatch error.
''''
'@Ignore ParameterCanBeByVal: False positive
'@Description "Populates a dynamic typed array."
Public Function ArrayXB(ByRef DynamicTypedArray As Variant, _
                   ByVal BaseIndex As Long, _
                   ParamArray ArrayElements() As Variant) As Variant
Attribute ArrayXB.VB_Description = "Populates a dynamic typed array."
    Guard.NotArray DynamicTypedArray
    Dim Elements As Variant
    Elements = UnfoldParamArray(ArrayElements)
    ReDim DynamicTypedArray(BaseIndex To UBound(Elements) + BaseIndex)
    
    Dim ElementIndex As Long
    For ElementIndex = 0 To UBound(Elements)
        DynamicTypedArray(ElementIndex + BaseIndex) = Elements(ElementIndex)
    Next ElementIndex
    ArrayXB = DynamicTypedArray
End Function
