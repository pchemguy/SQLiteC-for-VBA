---
layout: default
title: Notes
nav_order: 100
permalink: /notes
---

I am exploring SQLite C-language API and am using this page for now for notes taking.

**Development environment**
I use MSYS2/MinGW toolset on Windows 10 as my primary development [environment][MSYS2/MinGW Setup]. Unless otherwise indicated, run all scripts/commands from a MinGW shell.

**Source code**
The SQLite source code is available in several formats. The latest release ([zip][zip release] or [tar][tar release]) available from the [repository][Trunk README] is preferable. The following notes assume that the contents of the archive are in the “sqlite” folder produced via appropriate command (depending on the type of archive):

1. `tar xzf sqlite.tar.gz`
2. `PowerShell -Command "Expand-Archive -Path sqlite.zip -DestinationPath ."`

All source code path references are relative to the root source release folder (“sqlite”).

**SQLite API - main source files**
As far as SQLite's public API is concerned, one should focus on four files:

1. amalgamation sources, *sqlite3.c* and *sqlite3.h*, generated by the *make* command in the "build" folder;
2. TCL scripts, *tool/mksqlite3c.tcl* and *tool/mksqlite3h.tcl*, which generate the amalgamation. 

**SQLite amalgamation**
The *tool/mksqlite3c.tcl* and *tool/mksqlite3h.tcl* scripts generate amalgamation and optionally label public API. The primary purpose of this labeling is to provide a facility for switching calling conventions, but it also aids in extracting API prototypes. Amalgamation can be generated manually. While in the source release root, issue commands:

```bash
$ mkdir -p "build" && cd "build"
$ lt_cv_deplibs_check_method="pass_all" ../configure --with-tcl="${MINGW_PREFIX}/lib"
$ make .target_source
```

To generate amalgamation without forcing the labeling, use this command:

```bash
$ rm -f sqlite3.h sqlite3.c && make sqlite3.h sqlite3.c
```

To generate amalgamation with labeling, use this command:

```bash
$ tclsh ../tool/mksqlite3h.tcl "$(pwd)/.." --useapicall >sqlite3.h && tclsh ../tool/mksqlite3c.tcl --useapicall >sqlite3.c
```

Alternatively, place the [sqlite3.ref.sh][] script next to the "sqlite" folder or in an empty folder and run appropriate commands:

```bash
# Remove existing copies
$ rm -f sqlite/build/sqlite3.h sqlite/build/sqlite3.c 
# Force API labeling
$ USEAPI=1 ABI="STDCALL" MAKEDEBUG=""./sqlite3.ref.sh "sqlite3.h sqlite3.c"
# Skip API labeling
$ USEAPI="" ABI="" MAKEDEBUG=""./sqlite3.ref.sh "sqlite3.h sqlite3.c"
```

It is also instructive to build amalgamation: `./sqlite3.ref.sh sqlite3.dll`. See [SQLite ICU MinGW][] for additional information.

**Extracting API prototypes**
API can be extracted from sqlite3.h and sqlite3.c. The sqlite3.dll binary can also be examined for imports/exports (on Windows, the [ImpEx][] plugin for [Far Manager][] is quite convenient; [Dependency Walker][] may also be used).

With the "build" directory containing labeled amalgamation, <u>function prototypes</u> can be extracted from the header with the following command:

```bash
pcre2grep -M '^SQLITE_API[^;]*\);' "./sqlite/build/sqlite3.h" >sqlite3.h.APIl.txt
```

Alternatively, this regex pattern can match function names:

```bash
pcre2grep -M '^ *([a-zA-Z][a-zA-Z_0-9 ]+ \**)([a-zA-Z][a-zA-Z_0-9]* )?(sqlite3[_a-zA-Z0-9]+)(\([^;{]*)' "./sqlite/build/sqlite3.h" >sqlite3.h.APIn.txt
```

The following four commands can be used to extract function prototypes and implementations using the label or name matching (name matching only works correctly with the header file, which should have only exported declarations):

```bash
# Function prototype / label matching
pcre2grep -M '^SQLITE_API[^;{]*\);' "./sqlite/build/sqlite3.c" >sqlite3.c.sig.APIl.txt
# Function implementation / label matching
pcre2grep -M -o1 '^(SQLITE_API[^;{]*){' "./sqlite/build/sqlite3.c" >sqlite3.c.bod.APIl.txt
# Function prototype / name matching
pcre2grep -M '^ *([a-zA-Z][a-zA-Z_0-9 ]+ \**)([a-zA-Z][a-zA-Z_0-9]* )?(sqlite3[_a-zA-Z0-9]+)(\([^;{]*);' "./sqlite/build/sqlite3.c" >sqlite3.c.sig.APIn.txt
#Function implementation / name matching
pcre2grep -M -o1 -o2 -o3 -o4 '^ *([a-zA-Z][a-zA-Z_0-9 ]+ \**)([a-zA-Z][a-zA-Z_0-9]* )?(sqlite3[_a-zA-Z0-9]+)(\([^;{]*){' "./sqlite/build/sqlite3.c" >sqlite3.c.bod.APIn.txt
```

By comparing the output of these commands with the list of exported functions extracted from the binary, we can observe that the API of the RBU extension is missing from the sqlite3.h file. "tool/mksqlite3h.tcl" also misses a pattern for labeling RBU exports (sqlite3rbu\*).

This command filters out experimental, depricated, and CDECL APIs from previously created extract:

```bash
pcre2grep -M '^SQLITE_API [^S][^;]*SQLITE_APICALL[^;]*\);' "./sqlite3.h.APIl.txt" >sqlite3.h.APIll.txt
```

<!-- References -->

[MSYS2/MinGW Setup]: https://pchemguy.github.io/SQLite-ICU-MinGW/devenv

[zip release]: https://www.sqlite.org/src/zip/sqlite.zip?r=release
[tar release]: https://www.sqlite.org/src/tarball/sqlite.tar.gz?r=release
[Trunk README]: https://www.sqlite.org/cgi/src/doc/trunk/README.md
[sqlite3.ref.sh]: https://github.com/pchemguy/SQLite-ICU-MinGW/blob/master/MinGW/Proxy/sqlite3.ref.sh
[SQLite ICU MinGW]: https://pchemguy.github.io/SQLite-ICU-MinGW/
[ImpEx]: https://plugring.farmanager.com/plugin.php?pid=790
[Far Manager]: https://farmanager.com/index.php?l=en
[Dependency Walker]: https://www.dependencywalker.com/
